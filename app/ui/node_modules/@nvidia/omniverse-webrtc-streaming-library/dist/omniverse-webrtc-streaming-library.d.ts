import { UUID } from 'crypto';

/**
 * @class AppStreamer
 * @public
 *
 * Class AppStreamer can be used connect to, pause, un-pause, and terminate a streaming
 * Omniverse kit application session. It can also be used to send/receive custom messages
 * to/from the streaming kit application.
 */
export declare class AppStreamer {
    private static _stream;
    /**
     * Connects to the streaming kit app specified by the input props.
     *
     * @param   props The StreamProps that contain the initialization data for the stream.
     * @returns {Promise<StreamEvent>}
     */
    static connect(props: StreamProps): Promise<StreamEvent>;
    /**
     * Sends the provided custom message to the streaming kit application.
     *
     * @param message A custom message to send to the streaming application.
     * @returns {Promise<StreamEvent>}
     */
    static sendMessage(message: any): Promise<StreamEvent>;
    /**
     * Starts/restarts the stream.
     *
     * @returns {Promise<StreamEvent>}
     */
    static start(): Promise<StreamEvent>;
    /**
     * Stops (pauses) the stream.
     *
     * @returns {Promise<StreamEvent>}
     */
    static stop(): Promise<StreamEvent>;
    /**
     * Terminates the stream. The stream reference will be reset and will no
     * longer be accessible. Setup will need to be called to connect to a new session.
     *
     * If terminateApp is true, then the kit app instance will also be terminated
     * Currently only applies to OVC v1 stream API and NVCF.
     */
    static terminate(
    /** Whether or not to terminate the kit app instance. */
    terminateApp?: boolean, 
    /** Whether or not to force the termination. @deprecated */
    _force?: boolean): Promise<StreamEvent>;
    /**
     * Makes a request to update the resolution of the steaming application.
     *
     * @param width     The requested width
     * @param height    The requested height
     */
    static resize(width: number, height: number): Promise<StreamEvent>;
}

/**
 * Configuration parameters specific to starting a local or remote non-GFN stream.
 */
export declare type DirectConfig = DirectQueryProps & {
    /** The id of the video element created by the caller for the stream. @defaultValue 'remote-video' */
    videoElementId?: string;
    /** The id of the audio element created by the caller for the stream. @defaultValue 'remote-audio' */
    audioElementId?: string;
    /** Whether the stream reverse proxy requires a JWT token. @defaultValue false */
    authenticate?: boolean;
    /** Maximum number of reconnects to the stream the client should attempt. Range[0, max_integer]. @defaultValue 5 */
    maxReconnects?: number;
    /** Whether the client should send native touch events or emulate mouse events. @defaultValue false */
    nativeTouchEvents?: boolean;
    /** AKA Stream API URL. Endpoint for the OVC Stream API. Used to interact with the stream service rather
     * than the stream application. For example request a new session, terminate a session, etc. */
    backendUrl?: string;
    /** Defines the stream connection timeout interval, in milliseconds. @defaultValue 2000 */
    connectivityTimeout?: number;
    /** Enables Av1 support for streaming. */
    enableAV1Support?: boolean;
    /** A optional list of explicitly supported codecs, in descending order, according to priority */
    codecList?: string[];
    /** Whether to request a new session from the backend URL. @defaultValue false */
    newSession?: boolean;
    /** A function that will be called on update events. */
    onUpdate?: (message: StreamEvent) => void;
    /** A function that will be called when the stream is started. */
    onStart?: (message: StreamEvent) => void;
    /** A function that will be called when the stream is stopped. */
    onStop?: (message: StreamEvent) => void;
    /** A function that will be called when the stream is terminated. */
    onTerminate?: (message: StreamEvent) => void;
    /** A function that will be called by the service to pass stream StreamStats information. */
    onStreamStats?: (message: StreamEvent) => void;
    /** A function that will be called for custom events. */
    onCustomEvent?: (message: any) => void;
};

/**
 * @file      : DirectQueryParams.tsx
 * @summary   : Centralize props-to-query params logic.
 * @author    : Charles Best <cbest@nvidia.com>
 * @created   : 2024-09-25
 * @copywrite : 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * @exports   : DirectQueryParams
 */
/**
 * DirectQueryProps defines all possible parameters that are passed
 * down to Direct as URLSearchParams.
 */
export declare type DirectQueryProps = {
    /** The client JWT. */
    accessToken?: string;
    /** Whether to play the stream automatically on connection. @defaultValue true */
    autoLaunch?: boolean;
    /** @defaultValue free */
    cursor?: 'free' | 'hardware' | 'software';
    /** Requested frames per second for stream render. @defaultValue 60 */
    fps?: number;
    /** The stream resolution height of the rendering application. @defaultValue 1080 */
    height?: number;
    /** The port number for the media server. */
    mediaPort?: number;
    /** URL of the media server to connect the streaming kit app to. */
    mediaServer?: string;
    /** Whether to enable a mic. @defaultValue false */
    mic?: boolean;
    /** URL of a nucleus data server to connect the streaming kit app to. */
    nucleus?: string;
    /** URL of the streaming service server to connect to. */
    server?: string;
    /** Unique ID for the kit app streaming session. If no value is specified, a new
     * session will be requested. */
    sessionId?: string;
    /** The port number for the signaling server. @defaultValue 48322 */
    signalingPort?: number;
    /** URL of the signaling server to connect to. */
    signalingServer?: string;
    /** Path for resolving custom NVCF functions. */
    signalingPath?: string;
    /** Search params for the signaling server. NOTE that we cannot type this as individual parameters because they will need to be re-definable by library users. */
    signalingQuery?: URLSearchParams;
    /** The stream resolution width of the rendering application. @defaultValue 1920 */
    width?: number;
};

/**
 *  eAction
 *
 * eAction defines all caller-driven actions that can be requested for a stream.
 */
export declare enum eAction {
    unknown = "unknown",
    /** Make the stream active. */
    active = "active",
    /** Configure the stream. */
    configure = "configure",
    /** Connect to the stream. */
    connect = "connect",
    /** Get the stream. */
    get = "get",
    /** Request a new session from the streamer. */
    newSession = "newSession",
    /** Start the stream. */
    start = "start",
    /** Stop the stream. */
    stop = "stop",
    /** Stream. */
    stream = "stream",
    /** Terminate the stream. */
    terminate = "terminate",
    /** Update the stream. */
    update = "update",
    /** Send a message to the streaming application. */
    message = "message",
    /** Authenticate a user. */
    authUser = "authUser",
    /** Send clipboard text to the stream. */
    clipboardCopy = "clipboardCopy",
    /** Read clipboard text from the stream. */
    clipboardPaste = "clipboardPaste"
}

/**
 * eStatus
 *
 * Used in conjunction wth eAction, eStatus values define the current status of an
 * eAction.
 */
export declare enum eStatus {
    /** The status of the requested operation is unknown. */
    unknown = "unknown",
    /** The requested operation is in progress. */
    inProgress = "inProgress",
    /** The requested operation has completed successfully. */
    success = "success",
    /** The requested operation has been canceled */
    canceled = "canceled",
    /** The requested operation has completed unsuccessfully. */
    error = "error",
    /** The requested operation has completed with a warning. */
    warning = "warning",
    /** The requested operation is queued to run. */
    waiting = "waiting"
}

/**
 * GFNConfig
 *
 * Configuration parameters specific to starting a GFN stream.
 */
export declare type GFNConfig = {
    /** The GFN instance, which is imported in the calling application's index.html script block from https://sdk.nvidia.com/gfn/client-sdk/1.x/gfn-client-sdk.js */
    GFN: any;
    /** The ID of the catalog client. */
    catalogClientId: string;
    /** The ID of the client application. */
    clientId: string;
    /** The CMS ID of the client application. */
    cmsId: number;
    /** The nonce value used for logging in with nonce. */
    nonce?: string;
    /** The partner id. Required if logging in with nonce */
    partnerId?: string;
    /** Whether or not to start the stream with audio muted. @defaultValue true */
    muteAudio?: boolean;
    /** A function that will be called on update events. */
    onUpdate: (message: StreamEvent) => void;
    /** A function that will be called when the stream is started. */
    onStart: (message: StreamEvent) => void;
    /** A function that will be called when for custom events. */
    onCustomEvent?: (message: unknown) => void;
};

/**
 * @file      : LogFormat.ts
 * @summary   : Defines the format of the log file.
 * @author    : Charles Best <cbest@nvidia.com>
 * @created   : 2025-04-14
 * @copywrite : 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * @exports   : LogFormat
 */
/**
 * The format of the log file. JSON format provides a complete log of all event
 * fields. Text format is a more compact format that is easier to read for
 * debugging purposes, for example.
 */
export declare enum LogFormat {
    /** JSON format. */
    JSON = "json",
    /** Text format. */
    TEXT = "text"
}

/**
 * @file      : ConstEnumWrappers.ts
 * @summary   :
 * @author    : Charles Best <cbest@nvidia.com>
 * @created   : 2025-02-26
 * @copywrite : 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * @exports   : ConstEnumWrappers
 */
/**
 * Importing exported const enums is not supported by vite and tsc when
 * we have set "isolatedModules": true in tsconfig.json. So we redifine
 * these enum here.
 */
export declare enum LogLevel {
    /** Debug level logging. */
    DEBUG = "DEBUG",
    /** Info level logging. */
    INFO = "INFO",
    /** Warning level logging. */
    WARN = "WARN",
    /** Error level logging. */
    ERROR = "ERROR"
}

export declare type NVCFConfig = DirectConfig;

/**
 * StreamEvent
 *
 * This structure is used to pass steaming event information to the client. All event messages
 * will be in this format.
 */
export declare type StreamEvent = {
    /** The type of action that the event describes. */
    action: eAction;
    /** The status of the event action. */
    status: eStatus;
    /** Additional information about the action. */
    info: string | TypeError;
    /** The id of the session that sent the event. */
    sessionId?: UUID;
    /** The id of the sub-session that sent the event. */
    subSessionId?: UUID;
    /** The position of the event in the event queue. */
    queuePosition?: number;
    /** Time to completion of the requested action. */
    eta?: number;
    /** Performance stats information about the running stream. */
    stats?: StreamStats;
};

/**
 * StreamProps
 *
 * Data for starting a stream.
 */
export declare type StreamProps = {
    /** The source of the stream.
     * gfn indicates connection with a kit app streaming on GFN.
     * 'direct' covers all current non-GFN cases. */
    streamSource: StreamType;
    /** Configuration parameters for the underlying stream source class. */
    streamConfig: DirectConfig | GFNConfig;
    /** The log level to use for the stream. @defaultValue LogLevel.INFO */
    logLevel?: LogLevel;
    /** The format of the log file. @defaultValue LogFormat.JSON */
    logFormat?: LogFormat;
};

/**
 * StreamStats
 *
 * Performance stats information about the running stream.
 */
export declare type StreamStats = {
    /** Streaming codec. */
    codec: string;
    /** Streaming FPS */
    fps: number;
    /** Round trip delay (ms) */
    rtd: number;
    /** Average decode cost (ms) */
    avgDecodeTime: number;
    /** Total frame loss */
    frameLoss: number;
    /** Total packet loss */
    packetLoss: number;
    /** Available bandwidth (Mbps) */
    totalBandwidth: number;
    /** Current streaming bitrate (Mbps) */
    currentBitrate: number;
    /** Utilized bandwidth (%) */
    utilizedBandwidth: number;
    /** Streaming resolution width */
    streamingResolutionWidth: number;
    /** Streaming resolution height */
    streamingResolutionHeight: number;
};

export declare enum StreamType {
    /** The stream is a direct connection to the kit app. */
    DIRECT = "direct",
    /** The streaming app is running on GFN. */
    GFN = "gfn",
    /** The streaming app is running on NVCF. */
    NVCF = "nvcf"
}

export { }
